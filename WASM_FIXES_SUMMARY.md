# Краткая инструкция по исправлениям WASM-генератора

## Что было исправлено:

### 1. ✅ Локальные переменные в заголовке функции
- **Было:** `(local $x i32)` объявлялись внутри тела функции
- **Стало:** Все локальные переменные собираются из тела функции и объявляются в заголовке после параметров
- **Функции:** `collectLocalVars()`, `collectForLoopVars()` - собирают все переменные
- **Инициализация:** Выполняется как инструкции (`i32.const ...; local.set $x`)

### 2. ✅ Структурный control-flow
- **If:** `(if (then ...) (else ...))` вместо меток `$L0:`, `br_if $L0`
- **While:** `(block $end (loop $loop ... br_if $end ... br $loop ...))`
- **For:** Структурный стиль с `block` и `loop`

### 3. ✅ Исправлены инструкции f64
- **Было:** `f64.lt_s`, `f64.div_s` (не существуют)
- **Стало:** 
  - `i32.lt_s`, `i32.gt_s`, `i32.div_s` для integer
  - `f64.lt`, `f64.gt`, `f64.div` для real (без суффикса `_s`)

### 4. ✅ Print для f64
- Уже было правильно: `print_f64` для `f64`, `print_i32` для `i32`/`boolean`

## Пример валидного WAT-вывода

**Исходный код:**
```
routine Main() is
  var a : integer := 5
  print a
end
```

**Сгенерированный WAT:**
```wat
(func $Main
  (local $a i32)
  i32.const 5
  local.set $a
  local.get $a
  call $print_i32
)
```

**Ключевые моменты:**
- Локальная переменная `$a` объявлена в заголовке функции
- Инициализация выполняется как инструкции
- Используется структурный control-flow (нет меток в стиле ассемблера)
- Инструкции f64 исправлены (без суффикса `_s`)

## Файлы изменены:
- `src/wasm_compiler.cpp` - исправлены функции генерации WASM:
  - `compileRoutine()` - сбор локальных переменных в заголовке
  - `compileVarDecl()` - не объявляет локальные внутри тела
  - `compileStatement()` - переписан if/while/for на структурный стиль
  - `compileExpression()` - исправлены инструкции f64

